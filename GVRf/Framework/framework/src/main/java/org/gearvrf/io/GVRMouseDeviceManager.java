/* Copyright 2015 Samsung Electronics Co., LTD
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.gearvrf.io;

import org.gearvrf.GVRContext;
import org.gearvrf.GVRScene;
import org.gearvrf.utility.Log;

import android.content.Context;
import android.os.Handler;
import android.os.HandlerThread;
import android.os.Message;

import android.util.SparseArray;
import android.view.InputDevice;

import android.view.KeyEvent;
import android.view.MotionEvent;

/**
 * Use this class to translate MotionEvents generated by a mouse to manipulate
 * {@link GVRMouseController}s.
 * 
 */
class GVRMouseDeviceManager {
    private static final String TAG = GVRMouseDeviceManager.class
            .getSimpleName();
    private static final String THREAD_NAME = "GVRMouseManagerThread";
    private EventHandlerThread thread;
    private SparseArray<GVRMouseController> controllers;
    private boolean threadStarted = false;

    GVRMouseDeviceManager(Context context) {
        thread = new EventHandlerThread(THREAD_NAME);
        controllers = new SparseArray<GVRMouseController>();
    }

    GVRBaseController getCursorController(GVRContext context) {
        Log.d(TAG, "Creating Mouse Device");
        if (threadStarted == false) {
            Log.d(TAG, "Starting " + THREAD_NAME);
            thread.start();
            thread.prepareHandler();
            threadStarted = true;
        }
        GVRMouseController controller = new GVRMouseController(context,
                GVRCursorType.MOUSE, thread);
        int id = controller.getId();
        controllers.append(id, controller);
        return controller;
    }

    void removeCursorController(GVRBaseController controller) {
        int id = controller.getId();
        controllers.remove(id);

        // stop the thread if no more devices are online
        if (controllers.size() == 0 && threadStarted) {
            Log.d(TAG, "Stopping " + THREAD_NAME);
            thread.quitSafely();
            thread = new EventHandlerThread(THREAD_NAME);
            threadStarted = false;
        }
    }

    static class GVRMouseController extends GVRBaseController {
        private static final KeyEvent BUTTON_1_DOWN = new KeyEvent(
                KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_BUTTON_1);
        private static final KeyEvent BUTTON_1_UP = new KeyEvent(
                KeyEvent.ACTION_UP, KeyEvent.KEYCODE_BUTTON_1);

        private EventHandlerThread thread;
        private GVRContext context;
        private float x = 0.0f, y = 0.0f, z = -1.0f;

        GVRMouseController(GVRContext context, GVRCursorType cursorType,
                EventHandlerThread thread) {
            super(cursorType);
            this.context = context;
            this.thread = thread;
        }

        @Override
        protected void setKeyEvent(KeyEvent keyEvent) {
            super.setKeyEvent(keyEvent);
        }

        @Override
        public boolean dispatchKeyEvent(KeyEvent event) {
            if (event.isFromSource(InputDevice.SOURCE_MOUSE)) {
                return thread.submitKeyEvent(getId(), event);
            } else {
                return false;
            }
        }

        @Override
        public boolean dispatchMotionEvent(MotionEvent event) {
            if (event.isFromSource(InputDevice.SOURCE_MOUSE)) {
                return thread.submitMotionEvent(getId(), event);
            } else {
                return false;
            }
        }

        private boolean processMouseEvent(float x, float y, float z,
                MotionEvent event) {
            GVRScene scene = context.getMainScene();
            if (scene != null) {
                float depth = this.z;
                if (((depth + z) <= getNearDepth())
                        && ((depth + z) >= getFarDepth())) {
                    float frustumWidth, frustumHeight;
                    depth = depth + z;

                    // calculate the frustum using the aspect ratio and FOV
                    // http://docs.unity3d.com/Manual/FrustumSizeAtDistance.html
                    float aspectRatio = scene.getMainCameraRig()
                            .getCenterCamera().getAspectRatio();
                    float fovY = scene.getMainCameraRig().getCenterCamera()
                            .getFovY();
                    float frustumHeightMultiplier = (float) Math
                            .tan(Math.toRadians(fovY / 2)) * 2.0f;
                    frustumHeight = frustumHeightMultiplier * depth;
                    frustumWidth = frustumHeight * aspectRatio;

                    this.x = frustumWidth * -x;
                    this.y = frustumHeight * -y;
                    this.z = depth;
                }

                /*
                 * The mouse does not report a key event against the primary
                 * button click. Instead we generate a synthetic KeyEvent
                 * against the mouse.
                 */
                if (event.getAction() == MotionEvent.ACTION_DOWN) {
                    setKeyEvent(BUTTON_1_DOWN);
                } else if (event.getAction() == MotionEvent.ACTION_UP) {
                    setKeyEvent(BUTTON_1_UP);
                }
                setMotionEvent(event);
                super.setPosition(this.x, this.y, this.z);
                return true;
            }
            event.recycle();
            return false;
        }

        @Override
        public void setPosition(float x, float y, float z) {
            this.x = x;
            this.y = y;
            this.z = z;
            super.setPosition(x, y, z);
        }
    }

    private class EventHandlerThread extends HandlerThread {
        private static final int MOTION_EVENT = 0;
        private static final int KEY_EVENT = 1;
        private Handler handler;

        EventHandlerThread(String name) {
            super(name);
        }

        void prepareHandler() {
            handler = new Handler(getLooper()) {
                @Override
                public void handleMessage(Message msg) {
                    int id = msg.arg1;
                    switch (msg.what) {
                    case MOTION_EVENT:
                        MotionEvent motionEvent = (MotionEvent) msg.obj;
                        if (dispatchMotionEvent(id, motionEvent) == false) {
                            // recycle if unhandled.
                            motionEvent.recycle();
                        }
                        break;
                    case KEY_EVENT:
                        KeyEvent keyEvent = (KeyEvent) msg.obj;
                        dispatchKeyEvent(id, keyEvent);
                        break;
                    default:
                        break;
                    }
                }
            };
        }

        boolean submitKeyEvent(int id, KeyEvent event) {
            if (threadStarted) {
                Message message = Message.obtain(null, KEY_EVENT, id, 0, event);
                return handler.sendMessage(message);
            }
            return false;
        }

        boolean submitMotionEvent(int id, MotionEvent event) {
            if (threadStarted) {
                MotionEvent clone = MotionEvent.obtain(event);
                Message message = Message.obtain(null, MOTION_EVENT, id, 0,
                        clone);
                return handler.sendMessage(message);
            }
            return false;
        }

        private void dispatchKeyEvent(int id, KeyEvent event) {
            if (id != -1) {
                InputDevice device = event.getDevice();
                if (device != null) {
                    GVRMouseController mouseDevice = controllers.get(id);
                    mouseDevice.setKeyEvent(event);
                }
            }
        }

        // The following methods are taken from the controller sample on the
        // Android Developer web site:
        // https://developer.android.com/training/game-controllers/controller-input.html
        private boolean dispatchMotionEvent(int id, MotionEvent event) {
            InputDevice device = event.getDevice();
            if (id == -1 || device == null) {
                event.recycle();
                return false;
            }

            /*
             * Retrieve the normalized coordinates (-1 to 1) for any given (x,y)
             * value reported by the MotionEvent.
             */
            InputDevice.MotionRange range = device
                    .getMotionRange(MotionEvent.AXIS_X, event.getSource());
            float x = range.getMax() + 1;
            range = event.getDevice().getMotionRange(MotionEvent.AXIS_Y,
                    event.getSource());
            float y = range.getMax() + 1;
            float z;
            x = (event.getX() / x * 2.0f - 1.0f);
            y = 1.0f - event.getY() / y * 2.0f;
            if (event.getAction() == MotionEvent.ACTION_SCROLL) {
                z = (event.getAxisValue(MotionEvent.AXIS_VSCROLL) > 0 ? -1 : 1);
            } else {
                z = 0;
            }

            GVRMouseController controller = controllers.get(id);
            return controller.processMouseEvent(x, y, z, event);
        }

    }

    void stop() {
        if (threadStarted) {
            thread.quitSafely();
        }
    }
}